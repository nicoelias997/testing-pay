import { reactive } from 'vue'

import { defaultStyles } from './ModuleStyles'

export function useModule(type) {
  /*
    return styles by type:
    - background
      - includes: color, image, gradient (including its own settings, like rotation, how many "stops", etc.)
    - font
      - includes: family, weight, line-height, etc.

    So when importing to each module, you can pick the ones for that type of module. E.g:
    // TextModule.vue
    setup() {
      const {
        background,
        font,
        ...
      } = useModule()
    }
    TODO: check if there is a benefit on using reactive() in useModule()

    create common functions that can be used by all modules to modify module specific settings (fromJson, toJson, fromCss, toCss)

    Common properties (right now):
      - id - Ignore it - Should be autogenerated
      - type
      - uuid
      - index
      - _styles
      - styleTypes - Ignore it
      - config?
    ContainerModules (container, row and column) - DOES implement config property for some special settings
      // These all should migrate to single property: contents
      - rows?
      - columns?
      // From global - This is just as reference
      - config?
        - content
  */

  const styles = reactive(defaultStyles(type))

  const toCss = () => {
    return {
      'background-color': styles.background.color
    }
  }

  const fromJson = (json) => {
    for (const key in styles) {
      styles[key] = json[key]
    }
  }

  const setStyle = (prop, value) => {
    setTraverse(styles, prop, value)
  }

  const getTraverse = (obj, prop, defaultVal = null) => {
    if (prop == null) {
      return obj
    }

    if (obj.hasOwnProperty(prop)) {
      return obj[prop]
    }

    for (const segment in prop.split('.')) {
      try {
        obj = obj[segment]
      } catch (ex) {
        return defaultVal
      }
    }

    return obj
  }

  const setTraverse = (obj, prop, value) => {
    if (prop == null) {
      // return obj
      console.warn('Empty property name')
      return
    }

    if (obj.hasOwnProperty(prop)) {
      obj[prop] = value
      return
    }

    const segments = prop.split('.')
    try {
      setTraverse(obj[segments[0]], segments.slice(1).join(''), value)
    } catch (ex) {
      console.warn(`Invalid property ${segments[0]}`)
    }
    return
  }

  return {
    styles,
    toCss,
    fromJson,
    setStyle
  }
}
